<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[myDoc]]></title>
  <link href="blog.aaabc.top/atom.xml" rel="self"/>
  <link href="blog.aaabc.top/"/>
  <updated>2022-01-22T17:45:34+08:00</updated>
  <id>blog.aaabc.top/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[sql索引在哪些场景下会失效]]></title>
    <link href="blog.aaabc.top/16426162894392.html"/>
    <updated>2022-01-20T02:18:09+08:00</updated>
    <id>blog.aaabc.top/16426162894392.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16426162894392/1642844963778.jpg" alt="1642844963778" /></p>
<p>所谓失效。并不真的就是这个索引被删除了。而是在某些情况下，DBMS不会检索索引列表了。执行速度和没有这个索引时的速度一样。<br />
但是再执行另外的一条语句，同样的索引又正常起作用。所以索引的失效是针对某条sql语句，某个查询条件的，而不是针对索引本身的。</p>
<span id="more"></span><!-- more -->
<h2><a id="%E5%88%A4%E7%A9%BA%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>判空查询</h2>
<p>索引字段进行判空查询时。也就是对索引字段判断是否为NULL时。语句为is null 或is not null。</p>
<pre><code class="language-plain_text">***比如：***
```sql
select * from SoftWareDetailInfo where CreateTime is null;
此时就不检索time字段上的索引表了。也就是索引在这条语句执行时失效了。
```

***接着再执行：***
```sql
select * from SoftWareDetailInfo where CreateTime = '2015-04-11 00:00:00';
此时就会检索索引表了。索引又起作用了。
```
</code></pre>
<h2><a id="%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模糊查询</h2>
<p>对索引字段进行like查询时。比如：select * from SoftWareDetailInfo where SoftUseLine like '%OQC%'。不过网上有的例子说like 'xx%'索引起作用。我没试过。</p>
<h2><a id="%E9%9D%9E%E7%AD%89%E6%9F%A5%E8%AF%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>非等查询</h2>
<p>判断索引列是否不等于某个值时。‘!=’操作符。比如：select * from SoftWareDetailInfo where SoftUseLine != 0</p>
<h2><a id="%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>函数运算</h2>
<p>对索引列进行运算。这里运算包括+-*/等运算。也包括使用函数。</p>
<pre><code class="language-plain_text">***比如：***
```sql
select * from SoftWareDetailInfo where SoftUseLine +0= 0
此时索引不起作用。
select * from SoftWareDetailInfo where count(SoftUseLine) = 0
此时索引也不起作用。
```
***也就是说如果不是直接判断索引字段列，而是判断运算或其它函数处理后的索引列索引均不起作用。***
</code></pre>
<h2><a id="%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>复合索引</h2>
<p>复合索引中的前导列没有被作为查询条件。比如：Index_SoftWareDetail索引包含（a，b，c） 三列，但是查询条件里面，没有a，b 列，只有c 列，那么 Index_SoftWareDetail索引也不起作用。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MYSQL十大常用字符串函数]]></title>
    <link href="blog.aaabc.top/16426162759334.html"/>
    <updated>2022-01-20T02:17:55+08:00</updated>
    <id>blog.aaabc.top/16426162759334.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16426162759334/1642845155998.jpg" alt="1642845155998" /></p>
<h2><a id="concat" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>CONCAT()</h2>
<pre><code class="language-sql">/* 字符串拼接 */
SELECT CONCAT('MySQL', '字符串', '函数') AS str;

/* 若任意一字段为null，返回结果为null */
SELECT CONCAT('MySQL', NULL, '函数') AS str;

/* 字符串常量可直接连接在一起 */
SELECT 'MySQL' '字符串' '函数' AS str;

/* 使用指定分隔符，分隔符为null则返回结果为null */
SELECT CONCAT_WS('-', 'MySQL', NULL, '字符串') AS str1,
       CONCAT_WS(NULL, 'MySQL', '字符串') AS str2;
</code></pre>
<h2><a id="lower" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LOWER()</h2>
<pre><code class="language-sql">/* LOWER(str)和LCASE(str)函数用于将字符串转换为小写形式 */
SELECT LOWER('MySQL字符串函数') AS str1, LCASE('MySQL字符串函数') AS str2;

/* MySQL 大小写转换函数不支持二进制字符串（BINARY、VARBINARY、BLOB)），可以将其转换为非二进制的字符串之后再进行处理 */
SELECT LOWER(BINARY 'MySQL字符串函数') AS str1,
       LOWER(CONVERT(BINARY 'MySQL字符串函数' USING utf8mb4)) AS str2;
</code></pre>
<h2><a id="upper" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>UPPER()</h2>
<pre><code class="language-sql">/* UPPER(str)和UCASE(str)函数用于将字符串转换为大写形式 */
SELECT UPPER('MySQL字符串函数') AS str1, UCASE('MySQL字符串函数') AS str2;
</code></pre>
<h2><a id="length" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LENGTH()</h2>
<pre><code class="language-sql">/**
 * LENGTH(str)和OCTET_LENGTH(str)函数用于返回字符串的字节长度
 * 在 utf8mb4 编码中，一个汉字字符占用 3 个字节
 */
SELECT LENGTH('MySQL字符串函数') AS len1, OCTET_LENGTH('MySQL字符串函数') AS len2;

/* CHAR_LENGTH(str)和CHARACTER_LENGTH(str)函数用于返回字符串的字符长度，也就是字符个数 */
SELECT CHAR_LENGTH('MySQL字符串函数') AS len1, CHARACTER_LENGTH('MySQL字符串函数') AS len2;

/**
 * BIT_LENGTH(str)函数用于返回字符串的比特长度（比特数量）
 * 一个字节包含 8 个比特
 */
SELECT BIT_LENGTH('MySQL字符串函数') AS len;
</code></pre>
<h2><a id="substring" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SUBSTRING()</h2>
<pre><code class="language-sql">/* SUBSTRING(str,pos)、
   SUBSTRING(str FROM pos)、
   SUBSTRING(str,pos,len)
   以及SUBSTRING(str FROM pos FOR len)函数
   都可以用于返回从指定位置 pos 开始的子串，
   len 表示返回子串的长度；pos 为 0 表示返回空字符串。
   SUBSTR()和MID()函数都是 SUBSTRING() 函数的同义词，也支持以上 4 种形式。
 */
 SELECT SUBSTRING('MySQL字符串函数', 6) AS str1,
       SUBSTRING('MySQL字符串函数' FROM 6) AS str2,
       SUBSTRING('MySQL字符串函数', 6, 3) AS str3,
       SUBSTRING('MySQL字符串函数' FROM 6 FOR 3) AS str4,
       SUBSTRING('MySQL字符串函数', 0) AS str5;

/* 位置参数 pos 可以为负数，此时返回的子串从字符串右侧第 pos 个字符开始 */
SELECT SUBSTRING('MySQL字符串函数', -2) AS str1,
       SUBSTRING('MySQL字符串函数', -5, 3) AS str2;

/* LEFT(str,len)函数返回字符串 str 左侧的 len 个字符，RIGHT(str,len)函数返回字符串 str 右侧的 len 个字符 */
SELECT LEFT('MySQL字符串函数',5) AS str1,
       RIGHT('MySQL字符串函数',5) AS str2;

/** 
 * SUBSTRING_INDEX(str,delim,count)函数返回第 count 个分隔符 delim 之前的子串。
 * 如果 count 为正数，从左侧开始计数并返回左侧的所有字符；
 * 如果 count 为负数，从右侧开始计数并返回右侧的所有字符
 */
 SELECT SUBSTRING_INDEX('张三;李四;王五', ';', 2) AS str1,
       SUBSTRING_INDEX('张三;李四;王五', ';', -2) AS str2;
</code></pre>
<h2><a id="trim" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>TRIM()</h2>
<pre><code class="language-sql">/* TRIM([remstr FROM] str)函数用于返回删除字符串 str 两侧所有 remstr 字符串之后的子串，remstr 默认为空格 */
SELECT TRIM('  MySQL字符串函数  ') AS str1,
       TRIM('-' FROM '--MySQL字符串函数--') AS str2;

/**
 * TRIM([{BOTH | LEADING | TRAILING} [remstr] FROM] str)函数
 * 用于返回删除字符串 str 两侧/左侧/右侧所有 remstr 字符串之后的子串，
 * 默认删除两侧字符串（BOTH），
 * remstr 默认为空格
 */
SELECT TRIM(LEADING ' ' FROM '  MySQL字符串函数  ') AS str1,
       TRIM(TRAILING '-' FROM '--MySQL字符串函数--') AS str2,
       TRIM(BOTH '-' FROM '-MYSQL字符串函数-') AS str3;
</code></pre>
<h2><a id="lpad-rpad" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>LPAD()/RPAD()</h2>
<pre><code class="language-sql">/**
 * LPAD(str,len,padstr)函数表示字符串 str 的左侧使用 padstr 进行填充，直到长度为 len；
 * RPAD(str,len,padstr)函数表示在字符串 str 的右侧使用 padstr 进行填充，直到长度为 len
 * 当字符串 str 的长度大于 len 时，相当于从右侧截断字符串。
 */
SELECT LPAD(123, 6, '0') AS str1, LPAD(123, 2, '0') AS str2,
       RPAD(123, 6, '0') AS str1, RPAD(123, 2, '0') AS str1;

/* REPEAT(str,count)函数用于将字符串 str 复制 count 次并返回结果 */
SELECT REPEAT('1', 5) AS str;
</code></pre>
<h2><a id="instr" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>INSTR()</h2>
<pre><code class="language-sql">/* INSTR(str,substr)函数用于返回子串 substr 在字符串 str 中第一次出现的索引位置，没有找到子串时返回 0 */
select INSTR('MySQL字符串函数', '字符串') AS index1,
       INSTR('MySQL字符串函数', '日期') AS index2,
       INSTR('MySQL字符串函数', '') AS index3,
       INSTR('MySQL字符串函数', null) AS index4;

/**
 * LOCATE(substr,str)函数也可以用于返回子串 substr 在字符串 str 中第一次出现的索引位置，
 * 和 INSTR(str,substr) 函数唯一的不同就是参数的顺序相反。
 */
SELECT LOCATE('S','MySQL Server', 5) AS ind;

/* FIELD(str,str1,str2,str3,…) 函数返回字符串 str 在后续字符串列表中出现的位置，没有找到时返回 0。 */
SELECT FIELD('李四', '张三', '李四', '王五') AS ind;

/* FIND_IN_SET(str,strlist) 函数返回字符串 str 在列表字符串 strlist 中出现的位置，strlist 由 N 个子串使用逗号分隔组成 */
SELECT FIND_IN_SET('李四', '张三,李四,王五') AS ind;
</code></pre>
<h2><a id="replace" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>REPLACE()</h2>
<pre><code class="language-sql">/* REPLACE(str,from_str,to_str)函数用于将字符串 str 中所有的 from_str 替换为 to_str，返回替换后的字符串。 */
SELECT REPLACE('MySQL字符串函数', '字符串', '日期') AS str1,
       REPLACE('MySQL字符串函数', '字符串', '') AS str2;

/* INSERT(str,pos,len,newstr)函数用于在字符串 str 的指定位置 pos 之后插入子串 newstr，替换随后的 len 个字符。 */
SELECT INSERT('MySQL字符串函数', 6, 3, '日期') AS str;
</code></pre>
<h2><a id="reverse" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>REVERSE()</h2>
<pre><code class="language-sql">/* REVERSE(str)函数用于将字符串 str 中的字符顺序进行反转。 */
SELECT REVERSE('上海自来水来自海上')='上海自来水来自海上' AS &quot;回文&quot;;
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初探设计模式：代理模式]]></title>
    <link href="blog.aaabc.top/16426149259286.html"/>
    <updated>2022-01-20T01:55:25+08:00</updated>
    <id>blog.aaabc.top/16426149259286.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16426149259286/1642841158450.jpg" alt="1642841158450" /></p>
<blockquote>
<p>业务场景：学生信息新增与删除</p>
</blockquote>
<h2><a id="%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>接口与实现类</h2>
<pre><code class="language-java">public interface StudentService {

    /**
     * 新增学生
     */
    void insertStudent();

    /**
     * 删除学生
     */
    void deleteStudent();
}
</code></pre>
<pre><code class="language-java">public class StudentServiceImpl implements StudentService {
    /**
     * 新增学生
     */
    @Override
    public void insertStudent() {
        System.out.println(&quot;新增学生&quot;);
    }

    /**
     * 删除学生
     */
    @Override
    public void deleteStudent() {
        System.out.println(&quot;删除学生&quot;);
    }
}
</code></pre>
<h2><a id="%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>业务处理</h2>
<p>如果要针对新增或删除方法，新增日志输出或事务管理其他处理，难免要修改实现类</p>
<pre><code class="language-java">public class StudentServiceImpl implements StudentService {
    /**
     * 新增学生
     */
    @Override
    public void insertStudent() {
        System.out.println(&quot;方法开始执行&quot;);
        studentService.insertStudent();
        System.out.println(&quot;方法执行结束&quot;);
    }

    /**
     * 删除学生
     */
    @Override
    public void deleteStudent() {
        System.out.println(&quot;方法开始执行&quot;);
        studentService.deleteStudent();
        System.out.println(&quot;方法执行结束&quot;);
    }
}
</code></pre>
<h2><a id="%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分析</h2>
<p>类似这种修改方案，会导致代码越来越乱，可读性变差</p>
<blockquote>
<p>面向对象编程需要对扩展开放，对修改封闭。<br />
日志、事务等功能不属于学生管理的业务范畴，应当交给专门的类来做</p>
</blockquote>
<h2><a id="%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态代理</h2>
<h3><a id="%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%90%86%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>新增代理类</h3>
<pre><code class="language-java">public class StudentServiceProxy implements StudentService {

    private StudentService studentService;

    public StudentServiceProxy(StudentService service) {
        this.studentService = service;
    }

    /**
     * 新增学生
     */
    @Override
    public void insertStudent() {
        System.out.println(&quot;方法开始执行_静态代理&quot;);
        studentService.insertStudent();
        System.out.println(&quot;方法执行结束_静态代理&quot;);
    }

    /**
     * 删除学生
     */
    @Override
    public void deleteStudent() {
        System.out.println(&quot;方法开始执行_静态代理&quot;);
        studentService.deleteStudent();
        System.out.println(&quot;方法执行结束_静态代理&quot;);
    }
}
</code></pre>
<h3><a id="%E8%B0%83%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用</h3>
<p>这样新增代理类后，我们直接调用代理类就可以像业务类一样使用它，而不影响原有代码</p>
<pre><code class="language-java">public class StaticProxyClient {
    public static void main(String[] args) {
        StudentService proxy = new StudentServiceProxy(new StudentServiceImpl());
        proxy.insertStudent();
        System.out.println();
        proxy.deleteStudent();
    }
}
</code></pre>
<h2><a id="%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>动态代理</h2>
<h3><a id="%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分析</h3>
<blockquote>
<p>继通过<code>静态代理</code>解决问题后，有了新的问题：<br />
如果不止一个业务类需要做日志、事务等额外操作，我们都要给它新增代理类吗？<br />
显然不是这样，我们想要灵活运用代理，需要用到新的方案：<code>动态代理</code><br />
所谓动态代理，就是在程序运行时，动态的为被代理对象生成代理类，需要借助编程语言的反射特性</p>
</blockquote>
<p>Java为我们提供了十分方便的创建动态代理的工具包。当我们生成动态代理的时候，我们需要使用到<code>InvocationHandler</code>接口和<code>Proxy</code>类。</p>
<h3><a id="%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优化处理</h3>
<p>实现InvocationHandler接口，定义调用方法前后所做的事情：</p>
<pre><code class="language-java">public class MyInvocationHandler implements InvocationHandler {

    private Object service;

    public MyInvocationHandler(Object service){
        this.service = service;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(method.getName() + &quot;方法开始执行_动态代理&quot;);
        method.invoke(service, args);
        System.out.println(method.getName() + &quot;方法执行结束_动态代理&quot;);
        return null;
    }
}
</code></pre>
<h3><a id="%E8%B0%83%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用</h3>
<p>通过Proxy类的newProxyInstance方法，动态生成代理对象：</p>
<pre><code class="language-java">public class DynamicProxyClient {
    public static void main(String[] args) {
        StudentServiceImpl studentService = new StudentServiceImpl();
        InvocationHandler invocationHandler = new MyInvocationHandler(studentService);
        StudentService studentServiceProxy = (StudentService) Proxy.newProxyInstance(invocationHandler.getClass().getClassLoader(), studentService.getClass().getInterfaces(), invocationHandler);

        studentServiceProxy.insertStudent();
        System.out.println();
        studentServiceProxy.deleteStudent();
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初探设计模式：装饰器模式]]></title>
    <link href="blog.aaabc.top/16426152225186.html"/>
    <updated>2022-01-20T02:00:22+08:00</updated>
    <id>blog.aaabc.top/16426152225186.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16426152225186/1642840386624.jpg" alt="1642840386624" /></p>
<h2><a id="%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>模式介绍</h2>
<p>与<a href="16426149259286.html">代理模式</a>的中介性质有所不同的是，装饰器模式是为了扩展对象的功能，可以针对对象做更为细化的操作</p>
<p>装饰器模式大致分为四种核心角色：接口、实现类、抽象类、包装类</p>
<h3><a id="component%E6%8E%A5%E5%8F%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Component接口</h3>
<p>Component接口相当于接口根本的方法，比如现在有一个员工接口，员工基本职能为工作：</p>
<pre><code class="language-java">public interface Staff {

    /**
     * 工作
     */
    void work();
}
</code></pre>
<h3><a id="concretecomponent%E5%AE%9E%E7%8E%B0%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ConcreteComponent实现类</h3>
<p>ConcreteComponent类是员工接口的实现类。员工一、员工二：</p>
<pre><code class="language-java">public class StaffOne implements Staff {

    /**
     * 工作
     */
    @Override
    public void work() {
        System.out.println(&quot;一号程序员开始工作&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class StaffTwo implements Staff {

    /**
     * 工作
     */
    @Override
    public void work() {
        System.out.println(&quot;二号程序员开始工作&quot;);
    }
}
</code></pre>
<h3><a id="decorator%E6%8A%BD%E8%B1%A1%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Decorator抽象类</h3>
<p>Decorator类实现了Component接口，可以让每一个装饰器本身也可以被更外层的装饰器所包装，包装的方式就是把Component接口对象作为参数，传入到外层装饰器的构造函数当中。</p>
<pre><code class="language-java">public class StaffDecorator implements Staff {

    protected Staff StaffDecorator;

    public StaffDecorator(Staff staff) {
        this.StaffDecorator = staff;
    }

    /**
     * 工作
     */
    @Override
    public void work() {
        StaffDecorator.work();
    }
}
</code></pre>
<h3><a id="concretedecorator%E5%8C%85%E8%A3%85%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ConcreteDecorator包装类</h3>
<p><em>所有的包装类，都继承自<code>Decorator</code>抽象类，这么做是为了实现多层嵌套包装。扩充被包装类的功能</em></p>
<p><strong>开始工作，打开电脑：</strong></p>
<pre><code class="language-java">public class TurnOnComputerDecorator extends StaffDecorator{

    public TurnOnComputerDecorator(Staff staff) {
        super(staff);
    }


    /**
     * 工作
     */
    @Override
    public void work() {
        StaffDecorator.work();
        turnOnComputer();
    }

    /**
     * 打开工作电脑
     */
    private void turnOnComputer() {
        System.out.println(&quot;打开了工作电脑&quot;);
    }
}
</code></pre>
<p><strong>开始工作，打开电脑，接了杯咖啡：</strong></p>
<pre><code class="language-java">public class CoffeeDecorator extends StaffDecorator {

    public CoffeeDecorator(Staff staff) {
        super(staff);
    }

    /**
     * 工作
     */
    @Override
    public void work() {
        super.work();
        coffee();
    }

    private void coffee() {
        System.out.println(&quot;接了杯咖啡&quot;);
    }
}
</code></pre>
<h3><a id="%E5%8C%85%E8%A3%85%E7%B1%BB%E4%BD%BF%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>包装类使用</h3>
<pre><code class="language-java">public class DecoratorClient {
    public static void main(String[] args) {

        // 员工一开始工作，打开了工作电脑
        StaffDecorator staffOne  = new TurnOnComputerDecorator(new StaffOne());
        // 员工二开始工作，打开了工作电脑，接了杯咖啡（装饰器嵌套使用）
        StaffDecorator staffTwo  = new CoffeeDecorator(new TurnOnComputerDecorator(new StaffTwo()));

        staffOne.work();
        System.out.println();
        staffTwo.work();
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git常用指令]]></title>
    <link href="blog.aaabc.top/16426163434587.html"/>
    <updated>2022-01-20T02:19:03+08:00</updated>
    <id>blog.aaabc.top/16426163434587.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16426163434587/1642845303372.jpg" alt="1642845303372" /></p>
<span id="more"></span><!-- more -->
<h2><a id="git%E8%87%AA%E6%8A%A5%E5%AE%B6%E9%97%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>git自报家门</h2>
<pre><code class="language-shell">git config --global user.name &quot;DaimonDuan&quot;
git config --global user.email &quot;18621997334@163.com&quot;
</code></pre>
<h2><a id="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%89%88%E6%9C%AC%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建一个版本库</h2>
<pre><code class="language-shell">git init
</code></pre>
<h2><a id="%E6%B7%BB%E5%8A%A0%E6%96%87%E4%BB%B6%E5%88%B0%E7%89%88%E6%9C%AC%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>添加文件到版本库</h2>
<pre><code class="language-shell">// 添加到版本库
git add 文件名

// 确认添加（提交）到版本库
git commit -m &quot;版本信息&quot;
</code></pre>
<h2><a id="git-status%E6%9F%A5%E7%9C%8B%E4%BB%93%E5%BA%93%E7%8A%B6%E6%80%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>git status查看仓库状态</h2>
<pre><code class="language-shell">红色：文件修改未添加版本库
绿色：文件添加到版本库， 未提交
nothing to commit, working tree clean :版本库没有更新的文件
</code></pre>
<h2><a id="%E6%9F%A5%E7%9C%8Bgit%E7%9A%84%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E6%9C%80%E8%BF%91%E6%94%B9%E5%8F%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>查看git的历史记录(最近改变)</h2>
<pre><code class="language-shell">git log
git log --pretty=oneline
</code></pre>
<h2><a id="%E5%9B%9E%E9%80%80%E7%89%88%E6%9C%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>回退版本</h2>
<pre><code class="language-shell">git reset --hard 版本id
</code></pre>
<h2><a id="%E6%98%BE%E7%A4%BA%E6%89%80%E6%9C%89%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>显示所有历史记录的版本号</h2>
<pre><code class="language-shell">git reflog
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初探设计模式：建造者模式]]></title>
    <link href="blog.aaabc.top/16426151705513.html"/>
    <updated>2022-01-20T01:59:30+08:00</updated>
    <id>blog.aaabc.top/16426151705513.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16426151705513/1642843654845.jpg" alt="1642843654845" /></p>
<h2><a id="%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%88%AB%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>建造者模式与装饰器模式区别：</h2>
<p><a href="16426152225186.html">装饰器模式</a>是针对相同的处理方案，添加额外装饰<br />
建造者模式是针对固有的多种处理方式，选择性组合起来达成不同的结果</p>
<blockquote>
<p>建造者模式的关键，是将复杂对象的构建过程与它本身的表示分离，使得同样的构建过程可以创建不同的表示</p>
</blockquote>
<h2><a id="%E4%BB%A5%E9%A5%AD%E5%BA%97%E5%95%86%E5%93%81%E5%87%BA%E5%8D%95%E4%B8%BA%E4%BE%8B%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>以饭店商品出单为例：</h2>
<h3><a id="%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%95%86%E5%93%81%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>定义一个商品类</h3>
<pre><code class="language-java">public class Product {

    /**
     * 套餐内容
     */
    private ArrayList&lt;String&gt; parts = new ArrayList&lt;String&gt;();

    public void add(String part) {
        parts.add(part);
    }

    public void show() {
        System.out.println(parts);
    }
}
</code></pre>
<h3><a id="%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AE%9A%E4%B9%89%E5%87%BA%E5%BA%97%E5%AE%B6%E5%8F%AF%E4%BE%9B%E9%80%89%E6%8B%A9%E7%9A%84%E5%95%86%E5%93%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用抽象类定义出店家可供选择的商品</h3>
<pre><code class="language-java">public abstract class ProductBuilder {

    /**
     * 米饭
     */
    public abstract void rice();

    /**
     * 面条
     */
    public abstract void noodle();

    /**
     * 饮料
     */
    public abstract void drink();

    /**
     * 汤
     */
    public abstract void soup();

    /**
     * 获取结果
     * @return
     */
    public abstract Product build();
}
</code></pre>
<h3><a id="%E5%95%86%E5%93%81%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8E%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>商品的具体实现(后厨)</h3>
<pre><code class="language-java">public class ProductBuilderConcrete extends ProductBuilder {

    private Product product = new Product();

    /**
     * 米饭
     */
    @Override
    public void rice() {
        product.add(&quot;米饭&quot;);
    }

    /**
     * 面条
     */
    @Override
    public void noodle() {
        product.add(&quot;面条&quot;);
    }

    /**
     * 饮料
     */
    @Override
    public void drink() {
        product.add(&quot;饮料&quot;);
    }

    /**
     * 汤
     */
    @Override
    public void soup() {
        product.add(&quot;汤&quot;);
    }

    /**
     * 获取结果
     *
     * @return
     */
    @Override
    public Product build() {
        return product;
    }
}
</code></pre>
<h3><a id="%E5%95%86%E5%93%81%E9%80%89%E6%8B%A9%E6%90%AD%E9%85%8D%EF%BC%88%E5%A5%97%E9%A4%90%E9%80%89%E6%8B%A9%EF%BC%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>商品选择搭配（套餐选择）</h3>
<pre><code class="language-java">public class ProductDirectorOne {
    private ProductBuilder builder;

    public ProductDirectorOne(ProductBuilder builder) {
        this.builder = builder;
    }

    public void construct() {
        builder.drink();
        builder.noodle();
    }
}
</code></pre>
<pre><code class="language-java">public class ProductDirectorTwo {
    private ProductBuilder builder;

    public ProductDirectorTwo(ProductBuilder builder) {
        this.builder = builder;
    }

    public void construct() {
        builder.rice();
        builder.soup();
    }
}
</code></pre>
<h3><a id="%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8B%E5%8D%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>客户端下单</h3>
<pre><code class="language-java">public class BuilderModeClient {

    public static void main(String[] args) {
        // 顾客一的搭配
        customerOne();
        // 顾客二的搭配
        customerTwo();
    }

    private static void customerOne() {
        // 取出菜单
        ProductBuilder builder = new ProductBuilderConcrete();
        // 选择套餐
        ProductDirectorOne one = new ProductDirectorOne(builder);
        one.construct();
        // 交给后厨，准备上菜
        Product product = builder.build();
        product.show();
    }

    private static void customerTwo() {
        // 取出菜单
        ProductBuilder builder = new ProductBuilderConcrete();
        // 选择套餐
        ProductDirectorTwo two = new ProductDirectorTwo(builder);
        two.construct();
        // 交给后厨，准备上菜
        Product product = builder.build();
        product.show();
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初探设计模式：简单工厂模式]]></title>
    <link href="blog.aaabc.top/16426150996929.html"/>
    <updated>2022-01-20T01:58:19+08:00</updated>
    <id>blog.aaabc.top/16426150996929.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16426150996929/1642843880368.jpg" alt="1642843880368" /></p>
<h2><a id="%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>业务场景：</h2>
<p>单一接口，根据业务编码传参进行不同处理方式<br />
少量业务编码基本都是用条件判断做一下简单处理，但考虑到业务后期发展，业务编码会越来越多，很容易出现 <strong>if else</strong> 嵌套地狱</p>
<h2><a id="%E6%80%9D%E8%80%83%E4%B8%8E%E8%A7%A3%E5%86%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>思考与解决</h2>
<p>这种情况，我们就考虑使用<code>工厂模式</code>来对业务代码进行拆分，使不同处理逻辑划分更清晰</p>
<h3><a id="%E5%88%9B%E5%BB%BA%E4%B8%9A%E5%8A%A1%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%B9%B6%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%9A%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建业务接口，并定义一个业务实现方法</h3>
<pre><code class="language-java">public interface BusinessService {

    /**
     * 业务应用
     */
    void use();
}
</code></pre>
<h3><a id="%E5%88%9B%E5%BB%BA%E5%AE%9E%E7%8E%B0%E8%AF%A5%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%90%84%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建实现该接口的各个实现类</h3>
<pre><code class="language-java">public class BusinessServiceOneImpl implements BusinessService {

    /**
     * 业务应用
     */
    @Override
    public void use() {
        System.out.println(&quot;业务处理方案一&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class BusinessServiceTwoImpl implements BusinessService {

    /**
     * 业务应用
     */
    @Override
    public void use() {
        System.out.println(&quot;业务处理方案二&quot;);
    }
}
</code></pre>
<pre><code class="language-java">public class BusinessServiceThreeImpl implements BusinessService {

    /**
     * 业务应用
     */
    @Override
    public void use() {
        System.out.println(&quot;业务处理方案三&quot;);
    }
}
</code></pre>
<h3><a id="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%9A%E5%8A%A1%E5%B7%A5%E5%8E%82%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建一个业务工厂类</h3>
<pre><code class="language-java">public class BusinessServiceFactory {

    public BusinessService getBusinessService(String businessCode) throws Exception {

        if (businessCode == null) {
            return null;
        }

        switch (businessCode) {
            case &quot;000001&quot;:
                return new BusinessServiceOneImpl();
            case &quot;000002&quot;:
                return new BusinessServiceTwoImpl();
            case &quot;000003&quot;:
                return new BusinessServiceThreeImpl();
            default:
                throw new Exception(&quot;暂不支持此业务编码【&quot;+businessCode+&quot;】&quot;);
        }
    }
}
</code></pre>
<h3><a id="%E5%88%9B%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E6%A8%A1%E6%8B%9F%E4%B8%9A%E5%8A%A1%E8%AF%B7%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建客户端，模拟业务请求</h3>
<pre><code class="language-java">public class SimpleFactoryClient {

    /**
     * 服务消费者
     * @param args
     * @throws Exception
     */
    public static void main(String[] args) throws Exception {
        use(&quot;000001&quot;);
        use(&quot;000002&quot;);
        use(&quot;000003&quot;);
        use(&quot;000004&quot;);
    }

    /**
     * 服务提供者
     * @param businessCode
     * @throws Exception
     */
    public static void use(String businessCode) throws Exception {
        BusinessServiceFactory factory = new BusinessServiceFactory();
        BusinessService service = factory.getBusinessService(businessCode);
        service.use();
    }
}
</code></pre>
<h2><a id="%E5%88%86%E6%9E%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>分析</h2>
<p><strong>优点：</strong></p>
<blockquote>
<p>解耦、方便调用者创建对象、扩展性好。</p>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<p>每新增一个业务功能，就要加一个对应实现类、修改工厂类的出口方法。</p>
<p>这样会增加系统的复杂度，不利于维护。</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MarkDown语法]]></title>
    <link href="blog.aaabc.top/16427819836043.html"/>
    <updated>2022-01-22T00:19:43+08:00</updated>
    <id>blog.aaabc.top/16427819836043.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16427819836043/1642845424712.jpg" alt="1642845424712" /></p>
<h2><a id="%E8%84%9A%E6%B3%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>脚注</h2>
<p>这是一个脚注：<sup class="footnote-ref"><a href="#fn1" id="fnref1">1</a></sup></p>
<h2><a id="%E5%BE%85%E6%9B%B4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>待更</h2>
<section class="footnotes">
<ol>
<li id="fn1">
<p>这里是脚注信息 <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初探设计模式：抽象工厂模式]]></title>
    <link href="blog.aaabc.top/16426151396416.html"/>
    <updated>2022-01-20T01:58:59+08:00</updated>
    <id>blog.aaabc.top/16426151396416.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16426151396416/1642844164159.jpg" alt="1642844164159" /></p>
<h2><a id="%E6%80%9D%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>思考</h2>
<p><strong>在<a href="16426150996929.html">简单工厂模式</a>的基础上，做深层考虑：</strong></p>
<blockquote>
<p>一个接口，根据不同业务编码，我们建了一个工厂类来处理<br />
如果有多个接口都是类似情况呢？有没有办法合并一下？<br />
这个时候就要用到抽象工厂模式了</p>
</blockquote>
<h2><a id="%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现</h2>
<h3><a id="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%9A%E5%8A%A1%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%B9%B6%E5%AE%9A%E4%B9%89%E4%B8%9A%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建一个业务接口，并定义业务实现方法</h3>
<pre><code class="language-java">public interface OtherService {

    /**
     * 接口应用
     */
    void use();
}
</code></pre>
<h3><a id="%E5%88%9B%E5%BB%BA%E8%AF%A5%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%90%84%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建该接口的各个实现类</h3>
<pre><code class="language-java">public class OtherServiceOneImpl implements OtherService {

    /**
     * 接口应用一
     */
    @Override
    public void use() {
        System.out.println(&quot;接口应用一&quot;);
    }
}
</code></pre>
<h3><a id="%E4%B8%BA%E4%B8%A4%E7%A7%8D%E6%8E%A5%E5%8F%A3%E5%88%9B%E5%BB%BA%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为两种接口创建抽象工厂</h3>
<pre><code class="language-java">public abstract class AbstractFactory {

    /**
     * 获取工厂
     * @param businessCode
     * @return
     * @throws Exception
     */
    public abstract BusinessService getBusinessService(String businessCode) throws Exception;

    /**
     * 获取工厂
     * @param businessCode
     * @return
     * @throws Exception
     */
    public abstract OtherService getOtherService(String businessCode) throws Exception;
}
</code></pre>
<h3><a id="%E5%88%9B%E5%BB%BA%E5%B7%A5%E5%8E%82%E7%B1%BB%E6%89%A9%E5%B1%95%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建工厂类扩展抽象工厂</h3>
<pre><code class="language-java">public class BusinessServiceFactory extends AbstractFactory {

    /**
     * 获取工厂
     * @param businessCode
     * @return
     */
    @Override
    public BusinessService getBusinessService(String businessCode) throws Exception {
        if (businessCode == null) {
            return null;
        }

        switch (businessCode) {
            case &quot;000001&quot;:
                return new BusinessServiceOneImpl();
            case &quot;000002&quot;:
                return new BusinessServiceTwoImpl();
            case &quot;000003&quot;:
                return new BusinessServiceThreeImpl();
            default:
                throw new Exception(&quot;暂不支持此业务编码【&quot;+businessCode+&quot;】&quot;);
        }
    }

    /**
     * 获取工厂
     *
     * @param businessCode
     * @return
     * @throws Exception
     */
    @Override
    public OtherService getOtherService(String businessCode) throws Exception {
        return null;
    }
}
</code></pre>
<pre><code class="language-java">public class OtherServiceFactory extends AbstractFactory {

    /**
     * 获取工厂
     * @param businessCode
     * @return
     */
    @Override
    public BusinessService getBusinessService(String businessCode) throws Exception {
        return null;
    }

    /**
     * 获取工厂
     * @param businessCode
     * @return
     * @throws Exception
     */
    @Override
    public OtherService getOtherService(String businessCode) throws Exception {

        if (businessCode == null) {
            return null;
        }

        switch (businessCode) {
            case &quot;000001&quot;:
                return new OtherServiceOneImpl();
            default:
                throw new Exception(&quot;暂不支持此业务编码【&quot;+businessCode+&quot;】&quot;);
        }
    }
}
</code></pre>
<h3><a id="%E5%88%9B%E5%BB%BA%E5%B7%A5%E5%8E%82%E5%88%9B%E9%80%A0%E5%99%A8%EF%BC%8C%E9%80%9A%E8%BF%87%E6%8E%A5%E5%8F%A3%E7%B1%BB%E5%9E%8B%E8%8E%B7%E5%8F%96%E5%B7%A5%E5%8E%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建工厂创造器，通过接口类型获取工厂</h3>
<pre><code class="language-java">public class FactoryProducer {

    /**
     * 根据接口编码获取接口对应工厂
     * @param choice
     * @return
     */
    public static AbstractFactory getFactory(String choice) throws Exception {

        if (choice == null) {
            return null;
        }

        switch (choice) {
            case &quot;choice01&quot;:
                return new BusinessServiceFactory();
            case &quot;choice02&quot;:
                return new OtherServiceFactory();
            default:
                throw new Exception(&quot;暂不支持此接口编码【&quot;+choice+&quot;】&quot;);
        }
    }
}
</code></pre>
<h3><a id="%E5%88%9B%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E6%A8%A1%E6%8B%9F%E4%B8%9A%E5%8A%A1%E8%AF%B7%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建客户端，模拟业务请求</h3>
<pre><code class="language-java">public class AbstractFactoryClient {

    /**
     * 服务消费者
     * @param args
     * @throws Exception
     */
    public static void main(String[] args) throws Exception {
        use(&quot;choice01&quot;, &quot;000001&quot;);
        use(&quot;choice01&quot;, &quot;000002&quot;);

        use(&quot;choice02&quot;, &quot;000001&quot;);

        use(&quot;choice03&quot;, &quot;000001&quot;);
    }

    /**
     * 服务提供者
     * @param choice 接口类型
     * @param businessCode 业务编码
     * @throws Exception
     */
    public static void use(String choice, String businessCode) throws Exception {

        String choice01 = &quot;choice01&quot;;
        String choice02 = &quot;choice02&quot;;

        AbstractFactory factory = FactoryProducer.getFactory(choice);

        if (choice01.equals(choice)) {
            BusinessService service = factory.getBusinessService(businessCode);
            service.use();
        } else if (choice02.equals(choice)) {
            OtherService service = factory.getOtherService(businessCode);
            service.use();
        }
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaService]]></title>
    <link href="blog.aaabc.top/16426162543809.html"/>
    <updated>2022-01-20T02:17:34+08:00</updated>
    <id>blog.aaabc.top/16426162543809.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16426162543809/1642846028781.jpg" alt="1642846028781" /></p>
<h2><a id="%E6%80%9D%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>思考</h2>
<p>我们偶尔会面对这种局面：</p>
<blockquote>
<ul>
<li>自己做了一个springboot项目，仅限于局域网访问</li>
<li>环境是windows，不想让项目在ide运行，太占用空间</li>
<li>通过cmd命令java -jar运行起来的jar包，在cmd命令终止或窗口关闭时，服务会自动停止。</li>
</ul>
</blockquote>
<h2><a id="%E8%A7%A3%E5%86%B3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>解决</h2>
<blockquote>
<p>解决方案：使用<code>JavaService</code>将jar包注册为服务，使其常驻后台</p>
</blockquote>
<h3><a id="%E5%BA%94%E7%94%A8%E5%87%86%E5%A4%87%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>应用准备：</h3>
<ol>
<li>下载地址：<a href="http://download.forge.ow2.org/javaservice">http://download.forge.ow2.org/javaservice</a></li>
<li>64位系统（Java也是64位的）的话必须下载64位版本，比如：JavaService_2_0_10-amd64.zip。</li>
<li>打开CMD窗口，进入JavaService.exe所在目录，输入如下命令：</li>
</ol>
<pre><code class="language-bat">JavaService.exe -install deepblog &quot;%JAVA_HOME%&quot;\jre\bin\server\jvm.dll -Djava.class.path=C:\blogDev\deepblog.jar;&quot;%JAVA_HOME%&quot;\lib\tools.jar -Xms64M -Xmx512M -start org.springframework.boot.loader.JarLauncher
</code></pre>
<h3><a id="%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>参数解释：</h3>
<pre><code class="language-plain_text">-install deepblog：指定服务名，当前注册的服务名为：deepblog
-Djava.class.path=C:\blogDev\deepblog.jar：指定jar包的路径
-start org.springframework.boot.loader.JarLauncher：指定启动类，即 main 函数所在类，需要带上包名
</code></pre>
<h3><a id="%E6%B3%A8%E9%94%80%E6%9C%8D%E5%8A%A1%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注销服务：</h3>
<pre><code class="language-bat">JavaService.exe -uninstall deepblog
</code></pre>
<h3><a id="%E5%90%AF%E5%8A%A8%E6%9C%8D%E5%8A%A1%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>启动服务：</h3>
<pre><code class="language-bat">net start deepblog
</code></pre>
<h3><a id="%E5%81%9C%E6%AD%A2%E6%9C%8D%E5%8A%A1%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>停止服务：</h3>
<pre><code class="language-bat">net stop deepblog
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初探设计模式：单例模式]]></title>
    <link href="blog.aaabc.top/16426150512144.html"/>
    <updated>2022-01-20T01:57:31+08:00</updated>
    <id>blog.aaabc.top/16426150512144.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16426150512144/1642844327783.jpg" alt="1642844327783" /></p>
<h2><a id="%E6%80%9D%E8%80%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>思考</h2>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<blockquote>
<p>注意:</p>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
</blockquote>
<h2><a id="%E4%BA%94%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>五种实现方式</h2>
<h3><a id="%E6%87%92%E6%B1%89%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>懒汉式</h3>
<pre><code class="language-java">public class SingletonLazy {

    /**
     * 创建当前类私有化实例对象
     */
    private static SingletonLazy instance;

    /**
     * 设置构造函数私有化，使当前类不能被实例化
     */
    private SingletonLazy(){}

    /**
     * 获取唯一可用对象
     * 加锁synchronized 保证单例
     * @return
     */
    public static synchronized SingletonLazy getInstance() {

        if (instance == null) {
            instance = new SingletonLazy();
        }
        return instance;
    }

    /**
     * 内置方法
     */
    public void showMessage(){
        System.out.println(&quot;Hello World!&quot;);
    }
}
</code></pre>
<h3><a id="%E9%A5%BF%E6%B1%89%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>饿汉式</h3>
<pre><code class="language-java">public class SingletonHungry {

    /**
     * 创建当前类私有化实例对象
     */
    private static SingletonHungry instance = new SingletonHungry();

    /**
     * 设置构造函数私有化，使当前类不能被实例化
     */
    private SingletonHungry() {}

    /**
     * 获取唯一可用对象
     * @return
     */
    public static SingletonHungry getInstance() {
        return instance;
    }

    /**
     * 内置方法
     */
    public void showMessage(){
        System.out.println(&quot;Hello World!&quot;);
    }
}
</code></pre>
<h3><a id="%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>双重校验锁</h3>
<pre><code class="language-java">public class SingletonLocking {

    /**
     * 创建当前类私有化实例对象
     */
    private volatile static SingletonLocking instance;

    /**
     * 设置构造函数私有化，使当前类不能被实例化
     */
    private SingletonLocking() {}

    /**
     * 获取唯一可用对象
     * @return
     */
    public static SingletonLocking getInstance() {
        if (instance == null) {
            synchronized (SingletonLocking.class) {
                if (instance == null) {
                    instance = new SingletonLocking();
                }
            }
        }
        return instance;
    }

    /**
     * 内置方法
     */
    public void showMessage(){
        System.out.println(&quot;Hello World!&quot;);
    }
}
</code></pre>
<h3><a id="%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>静态内部类</h3>
<pre><code class="language-java">public class SingletonInner {

    private static class SingletonHolder {
        private static final SingletonInner INSTANCE = new SingletonInner();
    }

    /**
     * 设置构造函数私有化，使当前类不能被实例化
     */
    private SingletonInner() {}

    /**
     * 获取唯一可用对象
     * @return
     */
    public static final SingletonInner getInstance() {
        return SingletonHolder.INSTANCE;
    }

    /**
     * 内置方法
     */
    public void showMessage(){
        System.out.println(&quot;Hello World!&quot;);
    }
}
</code></pre>
<h3><a id="%E6%9E%9A%E4%B8%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>枚举</h3>
<pre><code class="language-java">public enum ENUM_SINGLETON {

    /**
     * 实例
     */
    INSTANCE;

    /**
     * 内置方法
     */
    public void showMessage(){
        System.out.println(&quot;Hello World!&quot;);
    }
}
</code></pre>
<h2><a id="%E8%B0%83%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>调用</h2>
<pre><code class="language-java">public class SingletonClient {

    public static void main(String[] args) {

        // 懒汉式
        lazy();

        // 饿汉式
        hungry();

        // 双重校验锁
        doubleCheck();

        // 静态内部类
        inner();

        // 枚举
        enums();
    }

    /**
     * 懒汉式
     */
    public static void lazy() {

        // 编译时错误，无法通过此种方式实例化
        //SingletonLazy instance = new SingletonLazy();

        // 获取唯一可用对象
        SingletonLazy instance = SingletonLazy.getInstance();
        instance.showMessage();
    }


    /**
     * 饿汉式
     */
    public static void hungry() {

        // 获取唯一可用对象
        SingletonHungry instance = SingletonHungry.getInstance();
        instance.showMessage();
    }

    /**
     * 双重校验锁
     */
    public static void doubleCheck() {

        // 获取唯一可用对象
        SingletonLocking instance = SingletonLocking.getInstance();
        instance.showMessage();
    }

    /**
     * 静态内部类
     */
    public static void inner() {

        // 获取唯一可用对象
        SingletonInner instance = SingletonInner.getInstance();
        instance.showMessage();
    }

    /**
     * 枚举
     */
    public static void enums() {

        ENUM_SINGLETON.INSTANCE.showMessage();
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中常见的日期类型操作]]></title>
    <link href="blog.aaabc.top/16426162168204.html"/>
    <updated>2022-01-20T02:16:56+08:00</updated>
    <id>blog.aaabc.top/16426162168204.html</id>
    <content type="html"><![CDATA[
<p><img src="media/16426162168204/1642846158514.jpg" alt="1642846158514" /></p>
<h2><a id="compareto" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>compareTo()</h2>
<p>调用Date自带的compareTo()方法来比较</p>
<pre><code class="language-java">	SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
	Date startDate = sdf.parse(&quot;2020-09-02&quot;);
	Date endDate = sdf.parse(&quot;2021-09-02&quot;);

	//当止期早于起期时，止期=起期
	int i = endDate.compareTo(startDate);
	if(i == -1) {
		System.out.println(&quot;止期早于起期:&quot;+i);
		endDate = startDate;
	}

	System.out.println(&quot;最终结果：startDate:&quot;+startDate+&quot;||endDate&quot;+endDate);
</code></pre>
<h2><a id="before%E3%80%81-after" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>before()、after()</h2>
<p>通过Date自带的before()或者after()方法比较</p>
<pre><code class="language-java">	SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
	Date startDate = sdf.parse(&quot;2020-09-02&quot;);
	Date endDate = sdf.parse(&quot;2021-09-02&quot;);

	//当止期早于起期时，止期=起期
	boolean b = endDate.before(startDate);
	if(b) {
		System.out.println(&quot;止期早于起期&quot;);
		endDate = startDate;
	}
	System.out.println(b);

	System.out.println(&quot;最终结果：startDate:&quot;+startDate+&quot;||endDate&quot;+endDate);
</code></pre>
<h2><a id="simpledateformat%E8%BD%AC%E6%8D%A2" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>SimpleDateFormat转换</h2>
<p>通过SimpleDateFormat将Date转换为String</p>
<pre><code class="language-java">	Date date = new Date();
	//如需时分秒则格式为：yyyy-MM-dd HH:mm:ss
	SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
	String time = sdf.format(date);
	System.out.println(&quot;当前时间:&quot;+time);
</code></pre>

]]></content>
  </entry>
  
</feed>
